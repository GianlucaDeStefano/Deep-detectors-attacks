import argparse
from abc import ABC, abstractmethod
from typing import Type
import io

import imageio

from Attacks.BaseAttack import BaseAttack
from Ulitities.Image.Picture import Picture
from Ulitities.Visualizers.BaseVisualizer import BaseVisualizer

class JpegCompressionAttack(BaseAttack):

    name = "BaseLotsAttack"

    def __init__(self, objective_image: Picture, objective_mask: Picture,
                debug_root="./Data/Debug/",verbose=True,quality=100):
        """
        Base class to implement various attacks
        :param objective_image: image to attack
        :param objective_mask: binary mask of the image to attack, 0 = authentic, 1 = forged
        :param name: name to identify the attack
        :param patch_size: size of the patch ot use to generate the target representation
        :param steps: total number of steps of the attack
        :param debug_root: root dolder in which save debug data generated by the attack
        """

        self.quality = quality
        self.compressed_image = None
        super().__init__(objective_image, objective_mask, debug_root,verbose)

    def _on_before_attack(self):
        super()._on_before_attack()
        self.write_to_logs("compression quality: {}".format(self.quality))

    @staticmethod
    def read_arguments(dataset_root) -> dict:
        """
        Read arguments from the command line or ask for them if they are not present, validate them raising
        an exception if they are invalid, it is called by the launcher script
        :param args: args dictionary containing the arguments passed while launching the program
        :return: kwargs to pass to the attack
        """
        kwarg = BaseAttack.read_arguments(dataset_root)

        parser = argparse.ArgumentParser()
        parser.add_argument("-q", '--quality', default=None,type=int, help='Quality of the jpeg '
                                                                                        'compression to 1pply, '
                                                                                        '100 best quality, '
                                                                                        '0 worst quality')

        args = parser.parse_known_args()[0]

        if args.quality is None:
            args.quality = int(input("Input the quality of the jpeg compression [1,100]:"))

        kwarg["quality"] = args.quality
        return kwarg

    def _attack(self):
        buf = io.BytesIO()
        imageio.imwrite(buf, self.original_objective_image, format='jpeg', quality=self.quality, subsampling=0)
        s = buf.getbuffer()
        self.compressed_image = Picture(imageio.imread(s, format='jpeg'))
        self.noise = self.original_objective_image - self.attacked_image

    @property
    def attacked_image(self):
        return self.compressed_image

    @property
    def attacked_image_monochannel(self):
        return self.compressed_image.one_channel()