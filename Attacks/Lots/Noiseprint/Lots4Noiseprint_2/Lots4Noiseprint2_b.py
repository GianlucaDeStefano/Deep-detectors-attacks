import os
from math import ceil

import numpy as np
from matplotlib import pyplot as plt
from tqdm import tqdm
import tensorflow as tf

from Attacks.Lots.Noiseprint.Lots4NoiseprintBase import Lots4NoiseprintBase
from Attacks.utilities.image import three_2_one_channel, one_2_three_channel
from Attacks.utilities.patches import get_authentic_patches
from Attacks.utilities.visualization import visuallize_array_values
from Detectors.Noiseprint.Noiseprint.noiseprint import NoiseprintEngine, normalize_noiseprint
from Ulitities.Image import Picture


class LotsNoiseprint2_b(Lots4NoiseprintBase):

    def __init__(self, target_image: Picture, mask: np.array, image_path, mask_path, qf: int = None,
                 patch_size: tuple = (8, 8),
                 steps=50, debug_root="./Data/Debug/", alpha=5, plot_interval=1):
        """
        Base class to implement various attacks
        :param target_image: image to attack
        :param mask: binary mask of the image to attack, 0 = authentic, 1 = forged
        :param image_path: path to the image's file
        :param mask_path: path to the image's mask's file
        :param qf: quality factor to use
        :param patch_size: size of the patch ot use to generate the target representation
        :param steps: total number of steps of the attack
        :param debug_root: root dolder in which save debug data generated by the attack
        """

        super().__init__(target_image, mask, "LOTS4Noiseprint_2.b", image_path, mask_path, qf, patch_size, steps,
                         debug_root, alpha, plot_interval)

    def _generate_target_representation(self):
        """
        Generate the target representation executing the following steps:

            1) Generate an image wise noiseprint representation on the entire image
            2) Divide this noiseprint map into patches
            3) Average these patches
            4) Create an image wide target representation by tiling these patches together

        :return: the target representation in the shape of a numpy array
        """

        image = self.original_image

        if len(image.shape) == 3 and image.shape[2] == 3:
            image = three_2_one_channel(image)

        # generate an image wise noiseprint representation on the entire image
        original_noiseprint = self._engine.predict(image)

        # exctract the authentic patches from the image
        authentic_patches = get_authentic_patches(original_noiseprint, self.mask, self.patch_size, True)

        # create target patch object
        target_patch = np.zeros(self.patch_size)

        # foreach patch
        for x_index, y_index, patch in tqdm(authentic_patches):
            assert (patch.shape == target_patch.shape)

            # add the contribution of this patch
            target_patch += patch / len(authentic_patches)

        # compute the tiling factors along the X and Y axis
        repeat_factors = (ceil(image.shape[0] / target_patch.shape[0]), ceil(image.shape[1] / target_patch.shape[1]))

        # tile the target representations together
        image_target_representation = np.tile(target_patch, repeat_factors)

        # cut away "overflowing" margins
        image_target_representation = image_target_representation[:image.shape[0], :image.shape[1]]

        self.target_representation = image_target_representation

        normalized_noiseprint = normalize_noiseprint(self.target_representation)

        plt.imsave(fname=os.path.join(self.debug_folder, "image-target.png"), arr=normalized_noiseprint, cmap='gray',
                   format='png')

        visuallize_array_values(target_patch, os.path.join(self.debug_folder, "image-target-raw.png"))

        return image_target_representation

    def _attack_step(self):
        """
        Perform step of the attack executing the following steps:

            1) Divide the entire image into patches
            2) Compute the gradient of each patch with respect to the patch-tirget representation
            3) Recombine all the patch-gradients to obtain a image wide gradient
            4) Apply the image-gradient to the image
        :return:
        """
        # get the 1 channel version of the image to attack as required by Noiseprint
        attacked_image_1c = tf.squeeze(self.original_image)
        if len(attacked_image_1c.shape) > 2:
            attacked_image_1c = three_2_one_channel(self.original_image)

        attacked_image_1c -= self.adversarial_noise

        assert (len(attacked_image_1c.shape) == 2)

        # variable to store the cumulative loss across all patches
        cumulative_loss = 0

        # image wide gradient
        image_gradient = np.zeros(attacked_image_1c.shape)

        if attacked_image_1c.shape[0] * attacked_image_1c.shape[1] < NoiseprintEngine.large_limit:
            # the image can be processed as a single patch
            image_gradient, cumulative_loss = self._get_gradient_of_patch(attacked_image_1c, self.target_representation)
        else:
            # the image is to big, we have to divide it in patches to process separately
            # iterate over x and y, strides = self.slide, window size = self.slide+2*self.overlap
            for x in range(0, attacked_image_1c.shape[0], self._engine.slide):
                x_start = x - self._engine.overlap
                x_end = x + self._engine.slide + self._engine.overlap
                for y in range(0, attacked_image_1c.shape[1], self._engine.slide):
                    y_start = y - self._engine.overlap
                    y_end = y + self._engine.slide + self._engine.overlap

                    # get the patch we are currently working on
                    patch = attacked_image_1c[
                            max(x_start, 0): min(x_end, attacked_image_1c.shape[0]),
                            max(y_start, 0): min(y_end, attacked_image_1c.shape[1])
                            ]

                    # get the desired target representation for this patch
                    target_patch = self.target_representation[
                                   max(x_start, 0): min(x_end, attacked_image_1c.shape[0]),
                                   max(y_start, 0): min(y_end, attacked_image_1c.shape[1])
                                   ]

                    patch_gradient, patch_loss = self._get_gradient_of_patch(patch, target_patch)

                    # discard initial overlap if not the row or first column
                    if x > 0:
                        patch_gradient = patch_gradient[self._engine.overlap:, :]
                    if y > 0:
                        patch_gradient = patch_gradient[:, self._engine.overlap:]

                    # add this patch loss to the total loss
                    cumulative_loss += patch_loss

                    # add this patch's gradient to the image gradient
                    # discard data beyond image size
                    patch_gradient = patch_gradient[:min(self._engine.slide, patch.shape[0]),
                                     :min(self._engine.slide, patch.shape[1])]

                    # copy data to output buffer
                    image_gradient[x: min(x + self._engine.slide, image_gradient.shape[0]),
                    y: min(y + self._engine.slide, image_gradient.shape[1])] = patch_gradient

        # scale the final gradient using the computed infinity norm
        image_gradient = image_gradient / np.max(np.abs(image_gradient))

        # save loss value to plot it
        self.loss_steps.append(cumulative_loss)

        # scale the final gradient using the computed infinity norm
        image_gradient = image_gradient / np.max(np.abs(image_gradient))

        # scale the gradient
        image_gradient = self.alpha * image_gradient / 255

        # convert it back to float to perform the next attack step
        self.attacked_image -= one_2_three_channel(image_gradient)

        # clip the image in the [0,1] range
        self.attacked_image = self.attacked_image.clip(0, 1)

        # recompute the adversarial noise parameter
        self.adversarial_noise += image_gradient

    def _get_gradient_of_patch(self, patch, target):

        with tf.GradientTape() as tape:
            tensor_image = tf.convert_to_tensor(patch[np.newaxis, :, :, np.newaxis])
            tape.watch(tensor_image)

            # perform feed foward pass
            noiseprint = tf.squeeze(self._engine._model(tensor_image))

            # compute the loss with respect to the target representation
            loss = tf.nn.l2_loss(target - noiseprint)

            # retrieve the gradient of the patch
            image_gradient = np.squeeze(tape.gradient(loss, tensor_image).numpy())

            loss = loss.numpy()

            return image_gradient, loss

    def _on_before_attack_step(self):
        """
        Check that the attack can be executed, if not, generate a target representation
        and execute it
        :return:
        """

        # if no target representation is present, generate it
        if self.target_representation is None:
            self._generate_target_representation()

        super()._on_before_attack_step()
