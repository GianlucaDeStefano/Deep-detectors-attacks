import logging
import os

import numpy as np
from matplotlib import pyplot as plt
from tqdm import tqdm
import tensorflow as tf

from Attacks.Lots.Noiseprint.Lots4NoiseprintBase import Lots4NoiseprintBase
from Attacks.utilities.image import three_2_one_channel, normalize_noiseprint_no_margins, one_2_three_channel
from Attacks.utilities.patches import get_authentic_patches, divide_in_patches, scale_patch
from Attacks.utilities.visualization import visuallize_array_values
from Ulitities.Image import Picture


class LotsNoiseprint1_a(Lots4NoiseprintBase):

    def __init__(self, target_image: Picture, mask: np.array, image_path, mask_path, qf: int = None,
                 patch_size: tuple = (16, 16), padding_size=(32, 32, 32, 32),
                 steps=50, debug_root="./Data/Debug/", alpha=5, plot_interval=1):
        """
        Base class to implement various attacks
        :param target_image: image to attack
        :param mask: binary mask of the image to attack, 0 = authentic, 1 = forged
        :param image_path: path to the image's file
        :param mask_path: path to the image's mask's file
        :param qf: quality factor to use
        :param patch_size: size of the patch ot use to generate the target representation
        :param steps: total number of steps of the attack
        :param debug_root: root dolder in which save debug data generated by the attack
        """

        assert (len(padding_size) == 4)

        # Define the dimension of the padding to apply to the patch before od using noiseprint
        self.padding_size = padding_size

        super().__init__(target_image, mask, "LOTS4Noiseprint_1.a", image_path, mask_path, qf, patch_size, steps,
                         debug_root, alpha, plot_interval)

    def _generate_target_representation(self):
        """
        Generate the target representation executing the following steps:

            1) Divide the image into patches
            2) Select only the authentic patches
            3) Foreach patch compute its noiseptint
            4) Average all the noiseprint maps

        :return: the target representation in the shape of a numpy array
        """

        # exctract the authentic patches from the image
        authentic_patches = self.original_image.one_channel.get_authentic_patches(self.mask, self.patch_size,
                                                                                  self.padding_size, force_shape=True)

        # create target patch object
        target_patch = np.zeros(self.patch_size)

        # generate authentic target representation
        self.write_to_logs("Generating target representation...", logging.INFO)
        for original_patch in tqdm(authentic_patches):
            assert (original_patch.clean_shape == target_patch.shape)

            noiseprint_patch = np.squeeze(self._engine._model(original_patch[np.newaxis, :, :, np.newaxis]))

            target_patch += original_patch.no_paddings(noiseprint_patch) / len(authentic_patches)

        self.write_to_logs("Target representation generated", logging.INFO)
        self.target_representation = target_patch

        # save a visualization of the target representation
        normalized_noiseprint = normalize_noiseprint_no_margins(self.target_representation)

        plt.imsave(fname=os.path.join(self.debug_folder, "image-target.png"), arr=normalized_noiseprint, cmap='gray',
                   format='png')

        visuallize_array_values(self.target_representation, os.path.join(self.debug_folder, "image-target-raw.png"))
        return self.target_representation

    def _attack_step(self):
        """
        Perform step of the attack executing the following steps:

            1) Divide the entire image into patches
            2) Compute the gradient of each patch with respect to the patch-tirget representation
            3) Recombine all the patch-gradients to obtain a image wide gradient
            4) Apply the image-gradient to the image
            5) Convert then the image to the range of values of integers [0,255] and convert it back to the range
               [0,1]
        :return:
        """

        # variable to store the cumulative loss across all patches
        cumulative_loss = 0

        # image wide gradient
        image_gradient = np.zeros((self.attacked_image.shape[0:2]))

        # divide the image into patches
        img_patches = self.attacked_image.one_channel.divide_in_patches(self.patch_size, self.padding_size)

        # analyze the image patch by patch
        for patch in tqdm(img_patches):
            # compute the gradient on the given patch
            with tf.GradientTape() as tape:
                tensor_patch = tf.convert_to_tensor(patch[np.newaxis, :, :, np.newaxis])
                tape.watch(tensor_patch)

                # perform feed foward pass
                patch_noiseprint = tf.squeeze(self._engine._model(tensor_patch))

                # remove the padding
                patch_noiseprint = patch.no_paddings(patch_noiseprint)

                # check if we are on a border and therefore we have to "cut"tareget representation
                target_patch_representation = np.copy(self.target_representation)

                if target_patch_representation.shape != patch_noiseprint.shape:
                    target_patch_representation = target_patch_representation[:patch_noiseprint.shape[0],
                                                  :patch_noiseprint.shape[1]]

                # compute the loss with respect to the target representation
                loss = tf.nn.l2_loss(target_patch_representation - patch_noiseprint)

                # retrieve the gradient of the patch
                patch_gradient = np.squeeze(tape.gradient(loss, tensor_patch).numpy())

                cumulative_loss += loss.numpy()

                # check that the retrieved gradient has the correct shape
                assert (patch_gradient.shape == patch.shape)

                # Add the contribution of this patch to the image wide gradient
                image_gradient = patch.add_to_image(image_gradient, patch_gradient)

        # save loss value to plot it
        self.loss_steps.append(cumulative_loss)

        # scale the final gradient using the computed infinity norm
        image_gradient = image_gradient / np.max(np.abs(image_gradient))

        # scale the gradient
        image_gradient = self.alpha * image_gradient / 256

        image_gradient = Picture.Picture("noise", image_gradient)

        # convert it back to float to perform the next attack step
        self.attacked_image = Picture.Picture((self.attacked_image - image_gradient.three_channel).clip(0, 1))

    def _on_before_attack_step(self):
        """
        Check that the attack can be executed, if not, generate a target representation
        and execute it
        :return:
        """

        # if no target representation is present, generate it
        if self.target_representation is None:
            self._generate_target_representation()

        super()._on_before_attack_step()
