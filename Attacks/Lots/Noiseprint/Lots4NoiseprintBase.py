import os.path
from abc import ABC, abstractmethod
from PIL import Image
import numpy as np
from cv2 import PSNR

from Attacks.Lots.BaseLotsAttack import BaseLotsAttack
from Attacks.utilities.image import three_2_one_channel, one_2_three_channel, normalize
from Attacks.utilities.visualization import visualize_noiseprint_step
from Detectors.Noiseprint.Noiseprint.noiseprint import NoiseprintEngine, normalize_noiseprint
from Detectors.Noiseprint.Noiseprint.noiseprint_blind import noiseprint_blind_post, genMappFloat
from Detectors.Noiseprint.Noiseprint.utility.utility import jpeg_quality_of_img, jpeg_quality_of_file
from Detectors.Noiseprint.Noiseprint.utility.utilityRead import imread2f
from Ulitities.Plots import plot_graph


class MissingTargetRepresentation(Exception):
    def __init__(self, image_name):
        super().__init__("No image found with name: {}".format(image_name))


class Lots4NoiseprintBase(BaseLotsAttack, ABC):

    def __init__(self, target_image: np.array, mask: np.array, name: str, image_path: str, mask_path, qf: int,
                 patch_size: tuple = (8, 8),
                 steps=50, debug_root="./Data/Debug/", alpha=5,plot_interval= 3):
        """
        Base class to implement various attacks
        :param target_image: image to attack
        :param mask: binary mask of the image to attack, 0 = authentic, 1 = forged
        :param name: name to identify the attack
        :param qf: quality factor to use
        :param patch_size: size of the patch ot use to generate the target representation
        :param steps: total number of steps of the attack
        :param debug_root: root folder in which save debug data generated by the attack
        """

        # check the passe patch is not too wide for be handled by noiseprint
        assert (patch_size[0] * patch_size[1] < NoiseprintEngine.large_limit)

        # Define object to contain the patch wise target representation
        self.target_representation = None

        super().__init__(target_image, mask, name, image_path, mask_path, patch_size, steps, debug_root, alpha,plot_interval)

        self.adversarial_noise = np.zeros((target_image.shape[0],target_image.shape[1]))

        try:
            qf = jpeg_quality_of_file(image_path)
        except:
            qf = 101

        # save the parameters of noiseprint
        self.qf = qf
        self._engine = NoiseprintEngine()
        self._engine.load_quality(qf)

        self.loss_steps = []
        self.psnr_steps = []
        self.noiseprint_variance_steps = []

        self.min_loss = float("inf")


    @abstractmethod
    def _generate_target_representation(self):
        raise NotImplemented

    def _on_after_attack_step(self):
        # compute PSNR between intial 1 channel image and the attacked one
        psnr = PSNR(self.target_image, self.attacked_image)
        self.psnr_steps.append(psnr)

        super()._on_after_attack_step()

        plot_graph(self.loss_steps, "Loss", os.path.join(self.debug_folder, "loss"))
        plot_graph(self.psnr_steps, "PSNR", os.path.join(self.debug_folder, "psnr"))
        plot_graph(self.noiseprint_variance_steps, "Variance", os.path.join(self.debug_folder, "variance"))

        if self.loss_steps[-1] < self.min_loss:

            self.min_loss = self.loss_steps[-1]
            # save the best adversarial noise
            np.save(os.path.join(self.debug_folder, 'best-noise.npy'), self.adversarial_noise)



    def plot_step(self):

        attacked_image_1c = self.attacked_image
        if len(attacked_image_1c.shape) > 2:
            attacked_image_1c = three_2_one_channel(self.attacked_image)

        noiseprint = self._engine.predict(attacked_image_1c)

        self.noiseprint_variance_steps.append(noiseprint.var())

        mapp, valid, range0, range1, imgsize, other = noiseprint_blind_post(noiseprint, attacked_image_1c)
        attacked_heatmap = genMappFloat(mapp, valid, range0, range1, imgsize)

        adversarial_noise = self.adversarial_noise

        if len(adversarial_noise.shape) == 3:
            adversarial_noise = three_2_one_channel(adversarial_noise)

        adversarial_noise = normalize(adversarial_noise)

        visualize_noiseprint_step(self.attacked_image, normalize_noiseprint(noiseprint), adversarial_noise,
                                  attacked_heatmap,
                                  os.path.join(self.debug_folder,"Steps", str(self.attack_iteration)))

    def _on_after_attack(self):
        """
        Function executed after finishing the attack pipeline
        :return:
        """
        super()._on_after_attack()
        image_path = os.path.join(self.debug_folder, "attacked image.png")

        # save attacked image
        im = Image.fromarray((self.attacked_image * 255).astype(np.uint8))
        im.save(image_path)

        # generate heatmap of the just saved image, just to be sure of the final result of the attack
        image, mode = imread2f(image_path, channel=1)
        noiseprint = self._engine.predict(image)

        mapp, valid, range0, range1, imgsize, other = noiseprint_blind_post(noiseprint, image)
        attacked_heatmap = genMappFloat(mapp, valid, range0, range1, imgsize)

        magnified_noise = normalize(self.adversarial_noise)

        magnified_noise = np.array(magnified_noise, dtype=np.int)

        image, mode = imread2f(image_path, channel=3)
        visualize_noiseprint_step(image, normalize_noiseprint(noiseprint), magnified_noise,
                                  attacked_heatmap,
                                  os.path.join(self.debug_folder, "resulting attack"))
