import os
from abc import ABC, abstractmethod

from matplotlib import pyplot as plt

from Attacks.BaseAttack import BaseAttack
from Attacks.utilities.image import normalize_noiseprint_no_margins
from Attacks.utilities.visualization import visuallize_array_values
from Ulitities.Image.Picture import Picture


class InvalidPatchSize(Exception):

    def __init__(self, reason):
        super().__init__("The passed patch size is invalid for the following reason: {}".format(reason))


class MissingTargetRepresentation(Exception):
    def __init__(self, image_name):
        super().__init__("No image found with name: {}".format(image_name))


def check_patch_size(patch_size):
    """
    Function used to check if the givedn patch sieze is valid or not
    :param patch_size:
    :return:
    """
    axis = 0
    for element in list(patch_size):
        if element < 1:
            raise InvalidPatchSize("The axis {} has a 0 or negative size: {}".format(axis, element))
        axis += 1

    return True


class BaseLotsAttack(BaseAttack, ABC):

    def __init__(self, name: str, objective_image: Picture, objective_mask: Picture,
                 target_representation_image: Picture = None,
                 target_representation_mask: Picture = None, patch_size: tuple = (8, 8),
                 steps=50, debug_root="./Data/Debug/", alpha=5, plot_interval=3):
        """
        Base class to implement various attacks
        :param objective_image: image to attack
        :param objective_mask: binary mask of the image to attack, 0 = authentic, 1 = forged
        :param name: name to identify the attack
        :param patch_size: size of the patch ot use to generate the target representation
        :param steps: total number of steps of the attack
        :param debug_root: root dolder in which save debug data generated by the attack
        """

        assert (check_patch_size(patch_size))
        self.patch_size = patch_size

        # Define object to contain the patch wise target representation
        self.target_representation = None

        self.alpha = alpha

        # bydefault, use the objective image and its mask mto generate the target representation
        self.target_representation_image = target_representation_image
        self.target_representation_mask = target_representation_mask

        # if not external image to generate the target representation is given use the objective image
        if self.target_representation_image is None:
            self.target_representation_image = objective_image
            self.target_representation_mask = objective_mask

        # if an external image is given without a proper mask, raise an exception
        elif self.target_representation_mask is None:
            raise Exception("Missing mask for external target representation image")

        super().__init__(name, objective_image, objective_mask, steps, debug_root, plot_interval)

    def _on_before_attack(self):

        super()._on_before_attack()

        # Before beginning the attack, generate the target representation
        if self.target_representation is None:
            # log infos
            self.write_to_logs(
                "Image used to generate the target representation:{}".format(self.target_representation_image.path))
            self.write_to_logs(
                "Mask used to generate the target representation:{}".format(self.target_representation_mask.path))

            # get images
            image = self.target_representation_image.one_channel.to_float()
            mask = self.target_representation_mask

            # generate taregt representation
            self.target_representation = self._generate_target_representation(image, mask)

        self.write_to_logs("Patch size:{}".format(str(self.patch_size)))
        self.write_to_logs("Alpha:{}".format(str(self.alpha)))

    @abstractmethod
    def _generate_target_representation(self, image: Picture, mask: Picture):
        raise NotImplemented
