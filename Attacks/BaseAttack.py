import argparse
import logging
import os
import time
from abc import ABC, abstractmethod
from datetime import datetime
from pathlib import Path
from typing import Type

import numpy as np
from cv2 import PSNR

from Datasets import get_image_and_mask
from Detectors.Noiseprint.utility.utility import jpeg_quality_of_file
from Ulitities.Image.Picture import Picture
from Ulitities.Visualizers.BaseVisualizer import BaseVisualizer
from Ulitities.Visualizers.ExifVisualizer import ExifVisualizer
from Ulitities.Visualizers.NoiseprintVisualizer import NoiseprintVisualizer
from Ulitities.io.folders import create_debug_folder


class BaseAttack(ABC):
    name = "BAseAttack"

    def __init__(self, objective_image: Picture, objective_mask: Picture,
                 debug_root="./Data/Debug/", verbose=True):
        """
        Base class to implement various attacks
        :param objective_image: image to attack
        :param objective_mask: binary mask of the image to attack, 0 = authentic, 1 = forged
        :param name: name to identify the attack
        :param steps: total number of steps of the attack
        :param debug_root: root folder in which save debug data generated by the attack
        :param plot_interval: frequency at which printing an extensive plot of a step
        """

        assert (objective_image.shape[0] == objective_mask.shape[0])
        assert (objective_image.shape[1] == objective_mask.shape[1])

        self.original_objective_image = objective_image
        self.objective_image_mask = objective_mask

        self.noise = np.zeros(objective_image.one_channel().shape)

        self.attack_iteration = 0
        self.debug_folder = debug_root

        # create debug folder
        self.debug_folder = create_debug_folder()

        # Remove all handlers associated with the root logger object.
        for handler in logging.root.handlers[:]:
            logging.root.removeHandler(handler)

        logging.basicConfig(format='%(message)s', filename=os.path.join(self.debug_folder, "logs.txt"),
                            level=logging.DEBUG)

        for name in logging.root.manager.loggerDict:
            logging.getLogger(name).disabled = True

        self.verbose = verbose

    def execute(self):
        """
        Launch the entire attack pipeline
        :return:
        """
        start_time = datetime.now()
        self.write_to_logs("Starting attack pipeline")

        self._on_before_attack()

        self._attack()

        self._on_after_attack()

        end_time = datetime.now()
        timedelta = end_time - start_time
        self.write_to_logs("Attack pipeline terminated in {}".format(timedelta))

    @abstractmethod
    def _attack(self):
        """
        Performs a step of the attack
        """
        raise NotImplemented

    def _on_before_attack(self):
        """
        Function executed before starting the attack pipeline
        :return:
        """

        # save image
        self.original_objective_image.save(os.path.join(self.debug_folder, "image.png"))

        # save mask
        self.objective_image_mask.to_int().save(os.path.join(self.debug_folder, "mask.png"))

        self.write_to_logs("Attack name: {}".format(self.name))
        self.write_to_logs("Attacking image: {}".format(self.original_objective_image.path))
        self.write_to_logs("Mask: {}".format(self.objective_image_mask.path))

        self.start_time = datetime.now()
        self.write_to_logs("Attack started at: {}".format(self.start_time))

    def _on_after_attack(self):
        """
        Function executed after finishing the attack pipeline
        :return:
        """

        image_path = os.path.join(self.debug_folder, "attacked image.png")

        best_attacked_image = Picture(self.attacked_image)
        best_attacked_image.save(image_path)

        # generate heatmap of the just saved image, just to be sure of the final result of the attack
        image = Picture(path=image_path)

        psnr = PSNR(self.original_objective_image.one_channel(), image.one_channel())

        note = "PSNR:{:.2f}".format(psnr)

        self.write_to_logs(note)

        # test the final result against noiseprint
        try:
            qf = jpeg_quality_of_file(self.original_objective_image.path)
        except:
            qf = 101

        if hasattr(self, "qf"):
            qf = self.qf
        NoiseprintVisualizer(qf).prediction_pipeline(image.to_float(),
                                                     os.path.join(self.debug_folder, "attacked image noiseprint.png"),
                                                     original_picture=self.original_objective_image.one_channel().to_float(),
                                                     note=note, omask=self.objective_image_mask,
                                                     debug=False,
                                                     adversarial_noise=self.noise)

        # test the final result against Exif
        ExifVisualizer().prediction_pipeline(image.to_float(),
                                             os.path.join(self.debug_folder, "attacked image exif.png"),
                                             original_picture=self.original_objective_image.one_channel().to_float(),
                                             note=note)

        self.end_time = datetime.now()


    def write_to_logs(self, message, force_print=True):
        """
        Add a new line to this attack's log file IF it exists
        :param message: message to write to the file
        :param level: level of importance of the attack
        :param should_print: should this message be even if ,verbose = False
        :return:
        """

        if force_print or self.verbose:
            print(message)

        if not self.debug_folder:
            return

        logging.info(message)

    @property
    def attacked_image(self):
        """
        Compute the attacked image using the original image and the cumulative noise to reduce
        rounding artifacts caused by translating the noise from one to 3 channels and vie versa multiple times,
        still this operation here is done once so some rounding error is still present.
        Use attacked_image_monochannel to get the one channel version of the image withoud rounding errors
        :return:
        """
        return Picture((self.original_objective_image - Picture(self.noise).three_channels()).clip(0,255))

    @property
    def attacked_image_monochannel(self):
        """
        Compute the attacked image using the original image and the compulative noise to reduce
        rounding artifacts caused by translating the nosie from one to 3 channels and vie versa multiple times
        :return:
        """
        return Picture((self.original_objective_image.one_channel() - self.noise).clip(0,255))

    @staticmethod
    def read_arguments(dataset_root) -> dict:
        """
        Read arguments from the command line or ask for them if they are not present, validate them raising
        an exception if they are invalid, it is called by the launcher script
        :param args: args dictionary containing the arguments passed while launching the program
        :return: kwargs to pass to the attack
        """
        parser = argparse.ArgumentParser()
        parser.add_argument("-i", '--image', required=True, help='Name of the input image, or its path')
        parser.add_argument("-m", '--mask', default=None, help='Path to the binary mask of the image')
        parser.add_argument("-s", '--steps', default=50, type=int, help='Number of attack steps to perform')
        args = parser.parse_known_args()[0]

        image_path = args.image
        if not image_path:
            image_path = str(input("Input a reference of the image to attack (path or name)"))

        mask_path = args.mask
        if Path(image_path).exists() and not mask_path:
            mask_path = str(input("Input the path to the mask of the image"))

        image, mask = get_image_and_mask(dataset_root, image_path, mask_path)

        kwarg = dict()
        kwarg["objective_image"] = image
        kwarg["objective_mask"] = mask
        return kwarg
